#!/usr/bin/env python
# pylint: disable=unused-argument, wrong-import-position
# This program is dedicated to the public domain under the CC0 license.

"""
First, a few callback functions are defined. Then, those functions are passed to
the Application and registered at their respective places.
Then, the bot is started and runs until we press Ctrl-C on the command line.

Usage:
Example of a bot-user conversation using nested ConversationHandlers.
Send /start to initiate the conversation.
Press Ctrl-C on the command line or send a signal to the process to stop the
bot.
"""

import logging
from typing import Any, Dict, Tuple

from telegram import __version__ as TG_VER

import os

try:
    from telegram import __version_info__
except ImportError:
    __version_info__ = (0, 0, 0, 0, 0)  # type: ignore[assignment]

if __version_info__ < (20, 0, 0, "alpha", 1):
    raise RuntimeError(
        f"This example is not compatible with your current PTB version {TG_VER}. To view the "
        f"{TG_VER} version of this example, "
        f"visit https://docs.python-telegram-bot.org/en/v{TG_VER}/examples.html"
    )
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    Application,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Top level conversation states
SELECTING_ACTION, SELECTING_SOURCE, SELECTING_THEMES, MAKING_QUIZ = map(
    chr, range(4))

# Source selection conversation states
SAVING_SOURCE = chr(4)

# Theme selection conversation states
AUTOGENERATING_THEMES, SELECTING_THEMES_FROM_LIST, MANUAL_THEME_ENTRY = map(
    chr, range(5, 8))

# Quiz generation conversation states
QUIZ_MADE = chr(8)

# Meta states
STOPPING, SHOWING = map(chr, range(8, 10))
# Shortcut for ConversationHandler.END
END = ConversationHandler.END

# Different constants for this example
(
    START_OVER,
    SOURCE,
    THEMES,
    QUIZ,
) = map(chr, range(10, 14))


# Top level conversation callbacks
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    """Conversation hub for choosing between main features of the bot."""
    text = (
        "You can add a source, select themes, or make a quiz. To abort, simply type /stop."
    )

    buttons = [
        [
            InlineKeyboardButton(
                text="Source", callback_data=str(SELECTING_SOURCE)),
        ],
        [
            InlineKeyboardButton(
                text="Themes", callback_data=str(SELECTING_THEMES_FROM_LIST)),
        ],
        [
            InlineKeyboardButton(text="Quiz", callback_data=str(MAKING_QUIZ)),
            InlineKeyboardButton(text="Done", callback_data=str(END)),
        ]
    ]
    keyboard = InlineKeyboardMarkup(buttons)

    if update.message:
        # If we're starting over we don't need to send a new message
        if context.user_data.get(START_OVER):
            await update.message.reply_text(text=text, reply_markup=keyboard)
        else:
            await update.message.reply_text(
                "Hi, I'm Quiz Bot and I'll assist your self-study with autogenerated quizzes."
            )
            await update.message.reply_text(text=text, reply_markup=keyboard)
    else:
        await update.callback_query.answer()
        await update.callback_query.edit_message_text(
            text=text, reply_markup=keyboard)

    context.user_data[START_OVER] = False
    return SELECTING_ACTION


async def selecting_source(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    '''Give the user the option to either send a file or a text message'''
    text = "Please send the source you want to add, You can either send a file or a text message. \n Supported types: only text atm"

    await update.callback_query.answer()
    await update.callback_query.edit_message_text(text=text)

    return SAVING_SOURCE


async def saving_source(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    '''Save the source to user_data'''

    if update.message is not None:
        source = update.message.text
    else:
        source = update.message.document.file_id
    context.user_data[SOURCE] = source
    context.user_data[START_OVER] = True
    await update.message.reply_text(f"Source saved")

    return await start(update, context)


async def selecting_themes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    '''Give the user the option to either auto generate themes or select from a list'''

    text = "Type in the themes you want to study, separated by commas. \n Example: 'Python, Telegram, Bot'"

    buttons = [
        [
            InlineKeyboardButton(
                text="Autogenerate", callback_data=str(AUTOGENERATING_THEMES)),
            InlineKeyboardButton(
                text="Manually Input", callback_data=str(MANUAL_THEME_ENTRY)),
        ]
    ]
    keyboard = InlineKeyboardMarkup(buttons)

    await update.callback_query.answer()
    await update.callback_query.edit_message_text(text=text, reply_markup=keyboard)

    return SELECTING_THEMES


async def auto_generating_themes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    '''Auto generate themes from the source'''
    return await start(update, context)


async def manual_theme_entry(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    '''Manually input themes'''
    return await start(update, context)


async def selecting_quiz(update: Update, context: ContextTypes.DEFAULT_TYPE) -> str:
    '''Select the quiz to be made'''

    text = "Type in the themes you want to study, separated by commas. \n Example: 'Python, Telegram, Bot'"

    buttons = [
        [
            InlineKeyboardButton(
                text="Autogenerate", callback_data=str(AUTOGENERATING_THEMES)),
            InlineKeyboardButton(
                text="Manually Input", callback_data=str(MANUAL_THEME_ENTRY)),
        ]
    ]
    keyboard = InlineKeyboardMarkup(buttons)

    await update.callback_query.answer()
    await update.callback_query.edit_message_text(text=text, reply_markup=keyboard)

    return SELECTING_THEMES


async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:

    """End Conversation by command."""

    await update.callback_query.answer()

    text = "See you around!"

    await update.callback_query.edit_message_text(text=text)

    return END


def main() -> None:
    """Run the bot."""
    # Create the Application and pass it your bot's token.
    application = Application.builder().token(os.getenv("BOT_TOKEN")).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            SELECTING_ACTION: [
                CallbackQueryHandler(
                    selecting_source, pattern="^" + str(SELECTING_SOURCE) + "$"),
                CallbackQueryHandler(
                    selecting_themes, pattern="^" + str(SELECTING_THEMES_FROM_LIST) + "$"),
                CallbackQueryHandler(
                    selecting_quiz, pattern="^" + str(MAKING_QUIZ) + "$"),
                CallbackQueryHandler(stop, pattern="^" + str(END) + "$"),
            ],
            SAVING_SOURCE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, saving_source),
            ],
            SELECTING_THEMES: [
                CallbackQueryHandler(
                    auto_generating_themes, pattern="^" + str(AUTOGENERATING_THEMES) + "$"),
                CallbackQueryHandler(
                    manual_theme_entry, pattern="^" + str(MANUAL_THEME_ENTRY) + "$"),
            ]
        },
        fallbacks=[CommandHandler("stop", stop)],
    )

    application.add_handler(conv_handler)

    # Run the bot until the user presses Ctrl-C
    application.run_polling()


if __name__ == "__main__":
    main()
